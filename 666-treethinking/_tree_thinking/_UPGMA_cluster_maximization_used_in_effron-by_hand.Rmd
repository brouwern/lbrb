---
title: "UPGMA - Cluster max"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{UPGMA - Cluster max}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

```{r  eval = T}
library(compbio4all)
```


## Data matrix

Data matrix from https://en.wikipedia.org/wiki/UPGMA#First_step

In some circles this is called "complete linkage clustering" or "farthest neighbour clustering"
https://en.wikipedia.org/wiki/Complete-linkage_clustering .  The max() function is used instead of the mean when recalculating the distance matrix.

This is in contrast to "nearest neighbour clustering" (not implemented) which uses the min() function.
https://en.wikipedia.org/wiki/Single-linkage_clustering


```{r}
# The data
#      a   b   c   d   e
a <- c(0,	 17, 21, 31, 23)
b <- c(17, 0,	 30, 34, 21)
c	<- c(21, 30, 0,  28, 39)
d	<- c(31, 34, 28,	0, 43)
e	<- c(23, 21, 39, 43,	0)

# Bind into a matrix
effron.mat1 <- rbind(a,b,c,d,e)

colnames(effron.mat1) <- c("a","b","c","d","e")

diag(effron.mat1) <- NA

effron.mat1[upper.tri(effron.mat1)] <- NA
```

## Data frame to store stuff


```{r}
n.taxa <- nrow(effron.mat1)
effron_output <- data.frame(it = c(1:n.taxa),
                           clust.i = NA,
                           clust.j = NA,
                           dist.ij = NA,
                           clust.u = NA,
                           branch.l.ij = NA)
```


## Algorithm - First step

### Determine minimum value in current matrix

The minimum distance
```{r}
dist.min.i <- min(effron.mat1, na.rm = T)
```

The index values of the minimum
```{r}
index.min.i <- which(effron.mat1 == dist.min.i, arr.ind =T)
index.row.i <- index.min.i[1]
index.col.i <- index.min.i[2]
```

We can get the names of our taxa using the 
```{r}
cluster.i2 <- rownames(effron.mat1)[index.row.i]
cluster.i1 <- colnames(effron.mat1)[index.col.i]
```


Add output to dataframe
```{r}
effron_output[1,"clust.i"] <- cluster.i1
effron_output[1,"clust.j"] <- cluster.i2
effron_output[1,"dist.ij"] <- dist.min.i
```


### Combine species into clade

Combine the two taxa names into a new name.  This can be done a couple ways.
```{r}
clade.i <- paste(cluster.i1,cluster.i2, sep = "")
```

We'll add this to the dataframe
```{r}
effron_output[1,"clust.u"] <- clade.i
```


### First branch length estimation

Branch length is distance/2 or d.ij/2
```{r}
effron_output[1,"branch.l.ij"] <- effron_output[1,"dist.ij"]/2
```


### First distance matrix update - WPGMA version

Distance is set as the MAXIMUM

#### ab to c

```{r}
Da_c <- 21
Db_c <- 30
Dab_c <- max(Da_c,Db_c)
```



#### ab to d


```{r}
Dab_d <- max(Da_d,Db_d)
```

#### ab to e

```{r}
Da_e <- 23
Db_e <- 21
Dab_e <- max(Da_e,Db_e)

```

The distances are
```{r}
Dab_c
Dab_d
Dab_e
```


### Update matrix with new distance

Old matrix has distances  from a and b to all other points: we want to replace these.  distances among c, d, and e are still the same values.

```{r}
effron.mat1
```

#### Illustration


Create smaller matrix with clade ab
```{r}
#       ab      c   d   e
ab  <- c(NA,    NA,  NA, NA)
c	  <- c(Dab_c, NA,  NA, NA)
d	  <- c(Dab_d, 28,	 NA, NA)
e	  <- c(Dab_e, 39,  43, NA)

effron.mat2 <- rbind(ab,c,d,e)
colnames(effron.mat2) <- c("ab","c","d","e")

```




## Algorithm - Second step

We've combined a and b and calculated the disnace of this clade (a,b) to the remaining taxa.  What is now the minimum distance?


The minimum distance of the current matrix
```{r}
dist.min.i <- min(effron.mat2, na.rm = T)
```

The index value of the current minimum
```{r}
index.min.i <- which(effron.mat2 == dist.min.i, arr.ind =T)
index.row.i <- index.min.i[1]
index.col.i <- index.min.i[2]
```

We can get the names of our taxa using the 

```{r}
cluster.i2 <- rownames(effron.mat2)[index.row.i]
cluster.i1 <- colnames(effron.mat2)[index.col.i]
```


Add output to dataframe
```{r}
effron_output[2,"clust.i"] <- cluster.i1
effron_output[2,"clust.j"] <- cluster.i2
effron_output[2,"dist.ij"] <- dist.min.i
```

### Combine species into clade

Combine the two taxa names into a new name.  This can be done a couple ways.
```{r}
clade.i <- paste(cluster.i1,cluster.i2, sep = "")
```

We'll add this to the dataframe

```{r}
effron_output[2,"clust.u"] <- clade.i
```


### Calculate branch length

Branch length is distance/2 or d.ij/2 = d.ab.e = 22/2
```{r}
effron_output[2,"branch.l.ij"] <- effron_output[2,"dist.ij"]/2
```

### Recalculate distance from abe to all remainign taxa

In the current matrix, the smallest distance is between ab and e

We therefore want to form a clade between ab and e (abe), the measure the distance from this clade to allthe other species.


#### abe to c

```{r}

Dab_c <- 30
De_c  <- 39
Dabe_c <- max(Dab_c,De_c)
```

#### abe to c

For abe to d

```{r}
Dab_d <- 34
De_d  <- 43
Dabe_d <- max(Dab_d , De_d)

```


Distances
```{r}
Dabe_c
Dabe_d
```

### Update the matrix

```{r}
abe <- c(NA,     NA,  NA)
c	   <- c(Dabe_c, NA,  NA)
d	   <- c(Dabe_d, 28,	 NA)


effron.mat3 <- rbind(abe,c,d)
colnames(effron.mat3) <- c("abe","c","d")
```

This matrix is different than the UPGMA matrix.

## Third step

### Calculate branch lengths


The minimum distance of the current matrix
```{r}
dist.min.i <- min(effron.mat3, na.rm = T)
```

The index value of the current minimum
```{r}
index.min.i <- which(effron.mat3 == dist.min.i, arr.ind =T)
index.row.i <- index.min.i[1]
index.col.i <- index.min.i[2]
```

We can get the names of our taxa using the 

```{r}
cluster.i2 <- rownames(effron.mat3)[index.row.i]
cluster.i1 <- colnames(effron.mat3)[index.col.i]
```


Add output to dataframe
```{r}
effron_output[3,"clust.i"] <- cluster.i1
effron_output[3,"clust.j"] <- cluster.i2
effron_output[3,"dist.ij"] <- dist.min.i
```

### Combine species into clade

Combine the two taxa names into a new name.  This can be done a couple ways.
```{r}
clade.i <- "cd"
clade.i <- paste("c","d",sep = "")

clade.i <- paste(cluster.i1,cluster.i2, sep = "")
```

We'll add this to the dataframe

```{r}
effron_output[3,"clust.u"] <- clade.i
```


### Calculate branch length

Branch length is distance/2 or d.ij/2 = d.d.e = 28/2
```{r}
effron_output[3,"branch.l.ij"] <- effron_output[3,"dist.ij"]/2
```




### Distance of c to abe and d to abe

```{r}

Dc_abe <- 39
Dd_abe <- 43

Ddc_abe <- max(Dc_abe , Dd_abe)


```

Create matrix
```{r}
abe <- c(NA,     NA)
cd	 <- c(Ddc_abe, NA)



effron.mat4 <- rbind(abe,cd)
colnames(effron.mat4) <- c("abe","cd")


```

## Finish up

The final entry of the matrix is 43  This means that the distnace from the clade abe to the clade de is 43, with branch length of 35/2 = 17.5

The minimum distance
```{r}
dist.min.i <- min(effron.mat4, na.rm = T)
```

The index value of the minimum
```{r}
index.min.i <- which(effron.mat4 == dist.min.i, arr.ind =T)
index.row.i <- index.min.i[1]
index.col.i <- index.min.i[2]
```

We can get the names of our taxa using the 

```{r}
cluster.i2 <- rownames(effron.mat4)[index.row.i]
cluster.i1 <- colnames(effron.mat4)[index.col.i]
```


Add output to dataframe
```{r}
effron_output[4,"clust.i"] <- cluster.i1
effron_output[4,"clust.j"] <- cluster.i2
effron_output[4,"dist.ij"] <- dist.min.i
```



### Combine species into clade

Combine the two taxa names into a new name.  This can be done a couple ways.
```{r}
clade.i <- paste(cluster.i1,cluster.i2, sep = "")
```

We'll add this to the dataframe

```{r}
effron_output[4,"clust.u"] <- clade.i
```


### Calculate branch length

Branch length is distance/2 or d.ij/2
```{r}
effron_output[4,"branch.l.ij"] <- effron_output[4,"dist.ij"]/2
```



## Plotting



Most of the time we don't include branch lengths in Newick format, but there is a way to do it. You don't need to know how to do this - this is just for illustration

```{r}
full.tree <- "((c:14,d:14):7.5,(e:11.5,(b:8.5, a:8.5):3):10.5);" # semi colon!
full.tree <-read.tree(text=full.tree)
plot(full.tree, main = "")
```


```{r}

```

